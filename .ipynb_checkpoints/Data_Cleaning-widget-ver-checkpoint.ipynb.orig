{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "view-in-github"
   },
   "source": [
    "<a href=\"https://colab.research.google.com/github/nadhiffarizi/Bangkit-Capstone/blob/main/Data_Cleaning.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "yzMzYWwc2x9N"
   },
   "source": [
    "# Pull Changes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "jYWA-fQpBjfZ"
   },
   "source": [
    "Don't forget \"Git Pull\" to :\n",
    "1.   Update all changes made by partner\n",
    "2.   Keep track of progress (last modified data record)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "btNsgQy21wCE",
    "outputId": "65b383a6-f05d-4243-821f-9c917e47d3b6"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Already up to date.\n"
     ]
    }
   ],
   "source": [
    "# from getpass import getpass\n",
    "# password = getpass('Password:')\n",
    "# !git clone https://nadhiffarizi:$password@github.com/nadhiffarizi/Bangkit-Capstone.git\n",
    "\n",
    "!git pull"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Import dataset and create dataframe from unmodified dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import pandas as pd\n",
    "\n",
    "# setup the path\n",
    "my_curr_path = os.getcwd()\n",
    "\n",
    "# open dataset & create dataframe contains origin data\n",
    "# https://www.kaggle.com/dionisiusdh/covid19-indonesian-twitter-sentiment#\n",
    "# the last argument from os.path.join() can be changed depends on what dataset to work on\n",
    "dataset_path = os.path.join(my_curr_path, \"Dataset\", \"indonesian_vaccination_tweets.csv\")\n",
    "df_origin = pd.read_csv(dataset_path)\n",
    "df_origin['tweet'] = df_origin['text']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "plTK3Gk1ELv3"
   },
   "source": [
    "Tracking progress\n",
    "\n",
    "Jupyter Notebook : Change option variabel value to user"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "V6zOk9hHB5DL",
    "outputId": "3cdc2abb-3baf-4bf6-dcb5-b7c4656208b2"
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<<<<<<< local <removed>\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "=======\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "my progress 26681 out of 52959 \n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      ">>>>>>> remote <modified: >\n"
     ]
    }
   ],
   "source": [
    "from ipywidgets import widgets\n",
    "from IPython.display import clear_output, display\n",
    "\n",
    "# Global variable\n",
    "progress = 0\n",
    "my_max_portion = 0\n",
    "track_file = \"\"\n",
    "\n",
    "# partner portion\n",
    "def portion(value):\n",
    "  global my_max_portion\n",
    "  if value == 1:\n",
    "    # means 'nadhif is selected'\n",
    "    my_max_portion = round(len(df_origin) / 2)\n",
    "  elif value ==2:\n",
    "    # 'means alif is selected'\n",
    "    my_max_portion = len(df_origin)\n",
    "  else:\n",
    "    # means select nothing\n",
    "    my_max_portion = 0\n",
    "  return my_max_portion\n",
    "\n",
    "# partner progress\n",
    "def partner_progress(track_file, value):\n",
    "    with open(track_file, 'r') as input:\n",
    "        MY_PROGRESS = input.read()\n",
    "    MY_PROGRESS = int(MY_PROGRESS)\n",
    "    print(\"my progress {} out of {} \".format(MY_PROGRESS, portion(value)))\n",
    "    return MY_PROGRESS\n",
    "\n",
    "\n",
    "# using dropdown to treat different user\n",
    "def dropdown_eventhandler(change):\n",
    "    global progress\n",
    "    global track_file\n",
    "    # clears output\n",
    "    clear_output(wait=True)\n",
    "    \n",
    "    if change.new == 1:\n",
    "        track_file = os.path.join(my_curr_path, \"Dataset\", \"nadhif.txt\")\n",
    "    elif change.new == 2:\n",
    "        track_file = os.path.join(my_curr_path, \"Dataset\", \"alif.txt\")\n",
    "    else:\n",
    "        return\n",
    "    value = change.new\n",
    "    progress = partner_progress(track_file, value)\n",
    "    \n",
    "opt = widgets.Dropdown(options=[('Nadhif', 1), ('Alif', 2), ('select', 3)],\n",
    "                     value=3,\n",
    "                    description='Who are you: ',\n",
    "                    )\n",
    "opt.observe(dropdown_eventhandler, names='value')\n",
    "display(opt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Yx1-x4SE2_5X"
   },
   "source": [
    "# Modify dataset"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## New dataframe for saving modified dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create new dataframe i.e df_modified\n",
    "df_modified = pd.DataFrame(columns=['data', 'label'])\n",
    "\n",
    "# saving dataset\n",
    "def save_dataset():\n",
    "    dataset_mod_path = os.path.join(my_curr_path, \"Dataset\", \"modified-dataset.csv\")\n",
    "    df_modified.to_csv(dataset_mod_path, mode='a' ,index = False, header=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Helper functions: Take actions based on option"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from builtins import input\n",
    "\n",
    "# helper function\n",
    "def save_tracking_file(iterator_now):\n",
    "    try:\n",
    "        with open(track_file, 'w') as output:\n",
    "            output.write(str(iterator_now))\n",
    "        print(\"Tracking file updated!\")\n",
    "    except:\n",
    "        print(\"Error to save tracking file\")\n",
    "        \n",
    "def truncate(tweet_ori, substring):\n",
    "    print(\"Type 'NO' if you wish not to procees\")\n",
    "    try: \n",
    "        truncated_tweet = re.sub(substring, '', tweet_ori)\n",
    "        print(\"Truncated tweet: \\n\")\n",
    "        print(truncated_tweet)\n",
    "        return truncated_tweet\n",
    "    except:\n",
    "        print(\"Substring do not contain in tweet\")\n",
    "        return tweet_ori\n",
    "\n",
    "def modify_copy_paste(tweet):\n",
    "    print(tweet)\n",
    "    return tweet\n",
    "    \n",
    "def labelling(tweet, label):\n",
    "    global df_modified\n",
    "    clear_output(wait=True)\n",
    "    print(label)\n",
    "    # create temporally dataframe\n",
    "    df_temp = pd.DataFrame([[tweet, label]], columns=['data', 'label'])\n",
    "    df_modified = df_modified.append(df_temp)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating widgets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%gui asyncio"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import asyncio"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# widget\n",
    "modify_opt = widgets.Dropdown(options=[('Label', 1), ('Copy-paste', 2), ('Truncate', 3), ('Exit', 4), \n",
    "                                       ('Skip', 5)],\n",
    "                              value=None,\n",
    "                              description='Your option: ', \n",
    "                              disabled=False)\n",
    "\n",
    "modify_label = widgets.Dropdown(options=[('Neutral', 0), ('Positive', 1), ('Negative', 2)],\n",
    "                               value=None,\n",
    "                               description='Your label: ',\n",
    "                               disabled=False)\n",
    "\n",
    "text_area = widgets.Textarea(value=None,\n",
    "                            placeholder='Type something',\n",
    "                            description='String:',\n",
    "                            disabled=False)\n",
    "\n",
    "button_submit = widgets.Button(description='Submit')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Handler widgets function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# modify option\n",
    "def opt_handler(widget, value):\n",
    "    print(\"\\nenter to modify option handler\")\n",
    "    display(widget)\n",
    "    future = asyncio.Future()\n",
    "    \n",
    "    # callbacks\n",
    "    def handler(change):\n",
    "        future.set_result(change.new)\n",
    "        widget.unobserve(handler, value)\n",
    "    widget.observe(handler, value)\n",
    "    return future\n",
    "\n",
    "# submit text\n",
    "def btn_handler(btn):\n",
    "    text_area.value = \"\"\n",
    "    display(text_area)\n",
    "    display(button_submit)\n",
    "    future = asyncio.Future()\n",
    "    def on_btn_clicked(btn):\n",
    "        future.set_result(text_area.value)\n",
    "        btn.on_click(on_btn_clicked, remove=True)\n",
    "    btn.on_click(on_btn_clicked)\n",
    "    return future\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Loops and modify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "# punctuations and pattern to remove \n",
    "pattern = \"(@\\w+)|(\\w+:\\/\\/\\S+)|(pic.twitter.com/\\S+)|[^A-Za-z0-9-]+\"\n",
    "\n",
    "\n",
    "async def loops_and_modify():\n",
    "    for i in range(progress, my_max_portion):\n",
    "        modify_opt.label = None\n",
    "        modify_label.label = None\n",
    "        # unprocessed tweet\n",
    "        tweet_ori = df_origin.loc[i, 'tweet']\n",
    "\n",
    "        #Remove all punctuation, url, mention, and twitter pic link\n",
    "        word_only = ' '.join(re.sub(pattern,\" \", tweet_ori).split())\n",
    "        if 'vaksin' in word_only:\n",
    "            print(word_only)\n",
    "\n",
    "            # options to modify dataset\n",
    "            op = await opt_handler(modify_opt, 'value')\n",
    "        else:\n",
    "            op = 4\n",
    "        if op ==1:\n",
    "            print(\"Enter labelling\")\n",
    "            label = await opt_handler(modify_label, 'value')\n",
    "            labelling(word_only, label)\n",
    "        elif op == 2:\n",
    "            print(\"Enter copy paste\")\n",
    "            btn_desc = await btn_handler(button_submit)\n",
    "            word_only = modify_copy_paste(btn_desc)\n",
    "            label = await opt_handler(modify_label, 'value')\n",
    "            labelling(word_only, label)\n",
    "\n",
    "        elif op == 3:\n",
    "            print(\"Enter truncate\")\n",
    "            word_only_temp = word_only\n",
    "            btn_desc = await btn_handler(button_submit)\n",
    "            while btn_desc != \"NO\":\n",
    "                clear_output()\n",
    "                word_only_temp = truncate(word_only_temp, btn_desc)\n",
    "                btn_desc = await btn_handler(button_submit)\n",
    "\n",
    "            word_only = word_only_temp\n",
    "\n",
    "            # labelling\n",
    "            label = await opt_handler(modify_label, 'value')\n",
    "            labelling(word_only, label)\n",
    "\n",
    "        elif op == 4:\n",
    "            print(\"Exit\")\n",
    "            save_dataset()\n",
    "            save_tracking_file(i)\n",
    "            return\n",
    "        else :\n",
    "            print(\"skipping tweet...\")\n",
    "            clear_output()\n",
    "\n",
    "        print(\"========================================================\")\n",
    "    print(\"You are done!\")\n",
    "    save_tracking_file(my_max_portion)\n",
    "    save_dataset()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Start editing and modify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "========================================================\n",
      "Dukung pemerintah mengambil tindakan keberpihakan ini berdasarkan pada keadaan nelayan di Indonesia yang secara perekonomian terpukul akibat COVID-19 erickthohir KemenBUMN BeliIkanNelayan\n",
      "\n",
      "enter to modify option handler\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "98ff7797b5a94b44a4e75d1a47327b32",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Dropdown(description='Your option: ', options=(('Label', 1), ('Copy-paste', 2), ('Truncate', 3), ('Exit', 4), …"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "async def main():\n",
    "#     task_loop = asyncio.create_task(loops_and_modify())\n",
    "#     await loops_and_modify()\n",
    "    asyncio.ensure_future(loops_and_modify())\n",
    "    \n",
    "# there's a slight different different using Ipython and python\n",
    "# jupyter (IPython ≥ 7.0) is already running an event loop:\n",
    "# Therefore you don't need to start the event loop yourself \n",
    "# and can instead call await main(url) directly, even if your code \n",
    "# lies outside any asynchronous functions.\n",
    "await main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "authorship_tag": "ABX9TyNnAmqAtaeTqG6jEAvNBGxi",
   "collapsed_sections": [],
   "include_colab_link": true,
   "name": "Data Cleaning.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
